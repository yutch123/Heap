// Heap
// Демоснтрирует работу с динамической памятью


#include <iostream>
using namespace std;

int* intOnHeap(); // возвращает целочисленную переменную из кучи
void leak1(); // создает утечку памяти
void leak2(); // создает другую утечку памяти

int main()
{
    int* pHeap = new int; // выделяет память в стеке и возвращает её адрес
    // После оператора new следует указать тип названчения, для которого мы хотим зарезервировать место
    // Часть утверждения, new int, выделяет достаточно памяти для одного целочисленного значения
    // и возвращает адрес в куче этого фрагмента памяти.

    // Другая часть этого утверждения, int* pHeap, объявляет локальный указатель с именем pHeap, который указывает на только что выделенный фрагмент куча.

    *pHeap = 10; // присваиваю фрагменту памяти значение 10

    /* Можно инициализировать память в куче в момент её выделения, путем размещения значения в скобках, после типа.
    * Сделать эьто проще, чем кажется: int* pHeap = new int(10)
    * Данное утверждение присваивает адрес этого фрагмента памяти указателю pHeap
    */

    cout << "* pHeap: " << *pHeap << "\n\n"; // отображаю значение из кучи, с помощью указателя pHeap

    int* pHeap2 = intOnHeap(); // Мы можем создать объект в куче во время работы функции
    // и вернуть указатель на него.

    cout << "* pHeap2: " << *pHeap2 << "\n\n"; // Далее функция возвращает указатель на этот фрагмент памяти. 
    // После этого в функции main() с помощью утверждения указателю pHeap2 присваивается адрес этого фрагмента памяти

    cout << "Freeing memory pointed to by pHeap. \n\n";
    delete pHeap; // освобождение паямти
    // нужно создавать оператор delete, для каждого созданного оператора new
    cout << "Freeing memory pointed to by pHeap2. \n\n";
    delete pHeap2;
    // избавляемся от висящих указателей
    pHeap = 0;
    pHeap2 = 0;
    return 0;
}

int* intOnHeap() // функция intOneHeap выделяет фрагмент памяти в куче для целочисленной переменной и присваивает её значение 20
{
    int* pTemp = new int(20);
    return pTemp;
}

void leak1()
{
    int* drip1 = new int(30); // выделяем фрагмент памяти в куче, для целочисленного значения
    // после чего функция заканчивается
}

void leak2()
{
    int* drip2 = new int(50);
    drip2 = new int(100);
    delete drip2;
}

